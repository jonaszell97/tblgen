
class Error <let msg: string, let fatal: i1 = false>
class Warning <let msg: string>
class Note <let msg: string>

/* ANY */
def err_generic_error : Error<"$0">
def fatal_any_fatal : Error<"$0", true>
def warn_generic_warn : Warning<"$0">
def note_generic_note : Note<"$0">

// frontend errors
def err_invalid_opt_level : Error<"optimization levels higher than $0 are unsupported">
def err_unsupported_opt_level : Error<"unsupported optimization level '$0'">
def err_expected_filename_after : Error<"expected filename after '$0'">
def err_unsupported_argument : Error<"unsupported argument '$0'">
def err_no_source_file : Error<"no source file specified">

def fatal_too_many_errors : Error<"too many errors emmitted, stopping now", true>
def err_internal_compiler_error : Error<"an internal compiler error occured">

/* PARSING */
def err_module_must_be_first : Error<"'module' declaration must appear first in a source file">
def err_unexpected_eof : Error<"unexpected end of file${ 0 | if(, expecting $1) }">
def err_unexpected_token : Error<"unexpected token $0${ 1 | if(, expecting $2) }">
def err_expecting_decl : Error<"unexpected token $0, expecting ${ 1 | if(top level ) }declaration">

def err_extraneous_paren : Error<"extraneous closing ${ 0 | select(')', '}', ']', '>') }">

def warn_inexact_fp : Warning<"floating point value cannot be represented exactly">
def note_to_match_this : Note<"to match this">

def err_invalid_traits : Error<"invalid '__traits' directive '$0'">
def err_duplicate_access_spec : Error<"duplicate access specifier">

def err_vararg_must_be_last : Error<"vararg arguments must come last in a function signature">
def note_previous_vararg_here : Note<"previous varargs here">

def err_vararg_default_value : Error<"varargs may not define a default value">
def err_expected_default_value : Error<"expecting default value">

def err_vararg_not_valid : Error<"${ 0 | select(subscript) } cannot be vararg">

def err_covar_convar_already_specified : Error<"${ 0 | select(covariance, contravariance) } already specified">

def err_inferred_arr_size_not_allowed : Error<"array type with inferred size is only allowed with variable declarations">

def err_mutating_non_method : Error<"expected method declaration after 'mutating'">
def err_cannot_be_static : Error<"${ 0 | select(associated type, static if, static for, static assert, static print, typedef, alias, initializer, deinitializer, enum case, inner record) } declaration cannot be static">
def err_cannot_have_access_spec : Error<"${ 0 | select(associated type, static if, static for, static assert, static print, typedef, alias, initializer, deinitializer, enum case, inner record) } declaration cannot have an access specifier">
def err_duplicate_decl_kind : Error<"unexpected declaration keyword">

def err_virt_method_outside_class : Error<"method marked ${ 0 | select(virtual,override) } may only appear in class declarations">

def err_overriding_decl_requires_override : Error<"overriding declaration requires 'override' keyword">

def err_override_no_matching_method : Error<"method marked 'override' does not correspond to any ${ 0 | if(overridable ) }declaration in a base class">
def note_override_cand_not_viable : Note<"base method not viable because of ${ 0 | select(incompatible signature, incompatible return type, incompatible 'throws' specification, incompatible 'unsafe' specification, incompatible 'async' specification, incompatible label) }">

def err_overriden_method_not_virtual : Error<"cannot override non-virtual method '$0'">
def note_declared_here : Note<"declared here">

def err_multiple_inheritance : Error<"only one inheritance clause is allowed">
def err_deinit_args : Error<"deinitializers cannot have arguments">
def err_prop_must_have_type : Error<"${ 0 | select(property, subscript) } must have a defined type">
def err_prop_must_have_get_or_set : Error<"${ 0 | select(property, subscript) } must have a getter or a setter">
def err_extension_template_params : Error<"extensions cannot have a template parameter list">

def err_duplicate_getter_setter : Error<"${ 0 | select(getter, setter) } already declared">

def err_last_match_case_empty : Error<"last case in a match statement may not be empty">
def err_expected_declaration : Error<"expected declaration after '$0'">
def err_declared_with_definition : Error<"'declare'd statements may not have a definition">

def err_bad_extern_kind : Error<"unknown extern kind '$0'">
def err_import_not_at_begin : Error<"'import' statements may only appear at the beginning of a file">

def err_labeled_args_last : Error<"labeled arguments must come last in a function call">

def err_anon_closure_arg : Error<"anonymous closure argument used outside of a closure">
def err_anon_closure_idx_too_high : Error<"closures may not have more than $0 arguments, $1 given">

def err_prec_prop_already_defined : Error<"${ 0 | select('higherThan' relationship, 'lowerThan' relationship, associativity, 'assignment') } already defined">
def err_bad_associativity : Error<"associativity must be either 'left' or 'right'">

def err_ownership_annot_not_allowed : Error<"ownership annotations can only be used on function argument types">

def err_must_be_top_level : Error<"${ 0 | select(precedence group, operator) } declaration cannot be in a nested scope">

def err_precedence_cycle : Error<"cycle in precedence relation between '$0' and '$1'">
def err_precedence_group_does_not_exist : Error<"precedence group '$0' does not exist">
def err_undefined_precedence : Error<"expression must be parenthesized because no precedence relation exists between '$0' and '$1'">

def err_undeclared_operator : Error<"undeclared operator '$0'">

def err_abstract_definition : Error<"abstract method '$0' cannot have a body">
def err_abstract_must_be_overriden : Error<"class '$0' must override abstract method '$1' of base class '$2'">

def err_macro_delim_must_be : Error<"macro delimiter must be either '()', '{}' or '[]'">
def err_variable_kind_must_be : Error<"macro variable kind must be one of 'expr', 'stmt', 'type' or 'decl'">
def err_expected_after_repetition : Error<"expected '*', '?' or '+' after repeated macro pattern">
def err_macro_does_not_exist : Error<"macro '$0' does not exist in current scope">
def err_macro_expects_delim : Error<"macro '$0' expects '$1' as its delimiter">
def err_macro_undeclared_variable : Error<"variable '$0' was not declared in macro pattern">
def err_macro_variable_unexpanded : Error<"macro variable '$0' can only be referenced in an expansion expression of the form '$$()...'">
def err_multiple_expanded_macro_variables : Error<"'$0' and '$1' appear in the same expansion context but have different amounts of repetition ($2 vs $3)">
def err_expansion_without_variable : Error<"expansion does not contain any expandable macro variable">
def err_macro_var_redeclaration : Error<"redeclaration of macro variable '$0'">
def err_macro_must_form : Error<"macro in ${ 0 | select(expression,statement,type,declaration) } position must form a valid ${ 0 | select(expression,statement,type,declaration) }">
def err_invalid_seperator_token : Error<"a valid seperator token (e.g. ';' or ',') must follow a${ 0 | select(_, n 'expr', 'stmt', 'decl', 'type',) } variable in a macro pattern">
def err_leftover_tokens_after_parsing : Error<"unexpected leftover tokens after parsing ${ 0 | select(expression,statement,type,declaration) }">
def err_could_not_match_pattern : Error<"could not match given arguments against any pattern of macro '$0'">
def note_pattern_not_viable_expected_tok : Note<"pattern not viable: expected $0 ${ 1 | if(or $1) }, found $2">
def note_pattern_here : Note<"pattern declared here">
def err_bad_macro_variable_kind : Error<"unexpected ${ 0 | select(expression,statement,type,declaration) } after expanding macro variable, expecting ${ 1 | select(expression,statement,type,declaration) }">

def note_in_expansion : Note<"in expansion of macro '$0' here">

// Attribute Errors
def err_attribute_no_args : Error<"attribute @$0 does not take any arguments">
def err_attribute_arg_count : Error<"attribute @$0 expects ${ 1 | select(at least, at most) } $2 ${ 2 | plural_s(argument) }, $3 given">
def err_attribute_bad_arg : Error<"attribute @$0 expects ${ 1 | select(integer literal, floating point literal, string literal, expression, type, one of '$3') } as ${ 2 | ordinal } argument">

def err_attribute_applicability : Error<"attribute @$0 is not applicable to ${ 1 | select(declarations, statements, expressions, types) }">
def err_attribute_not_valid_here : Error<"attribute @$0 is not allowed here">
def err_attr_can_only_be_used : Error<"attribute @$0 can only be used on ${ 1 | select(declarations, function declarations, record declarations, function types) }">
def err_implicit_attr_not_valid : Error<"@implicit can only be used on operator function or initializer declarations">

// @align
def err_attr_align_bad_arg : Error<"1st argument to @align must be ${ 0 | select(integral, a power of two, greater than or equal to zero) }">
def err_attr_align_lower_than_natural : Error<"alignment value cannot be lower than the natural alignment of a type ($0 < $1)">
def err_attr_align_too_high : Error<"alignment must be 268435456 bytes or smaller">

/* PREPROCESSING*/
def err_max_macro_recursion_depth : Error<"maximum macro recursion depth reached ($0) in expansion of macro $1">

/* TYPE ERRORS */
def warn_implicit_cast : Warning<"implicit cast from $0 to $1">
def err_type_mismatch : Error<"incompatible types $0 and $1">
def err_no_implicit_conv : Error<"no implicit conversion from '$0' to '$1'">
def err_unexpected_value : Error<"expected $0">

def err_expression_in_type_position : Error<"expression cannot be used as a type">

def err_no_explicit_cast : Error<"no known explicit conversion from $0 to $1">

def err_not_existential : Error<"cannot apply type-union operator to non-existential type '$0'">

def err_return_type_mismatch : Error<"returned value of type $0 is not compatible with declared return type $1">
def err_cond_not_boolean : Error<"${ 0 | select(if,while,for,ternay operator '?:') } condition must be boolean">
def err_if_let_must_have_value : Error<"'if let' declaration must define a value">
def err_if_let_val_must_be_boolean : Error<"'if let' declaration type must be boolean-convertible">
def err_range_not_iterable : Error<"range expression of for-in statement must conform to 'Iterable'">
def err_dict_key_not_hashable : Error<"dictionary keys must conform to 'Hashable'">
def err_requires_contextual_type : Error<"${ 0 | select('none', '__nullptr', member lookup with leading period)} requires a contextual type">
def err_not_string_representable : Error<"value must conform to 'StringRepresentable'">
def err_illegal_subscript : Error<"subscript operator cannot be applied to value of type $0">
def err_subscript_index_not_integral : Error<"subscript indices have to be integral">
def err_cannot_assign_void : Error<"cannot assign value of type void">
def err_reserved_identifier : Error<"$0 is a reserved identifier">
def err_value_not_a_pointer : Error<"value is not a pointer">
def err_type_not_callable : Error<"given type $0 is not callable">
def err_assign_non_mutating_self : Error<"cannot reassign 'self' in a non-mutating method">
def err_assign_to_rvalue : Error<"cannot assign to rvalue of type $0">
def err_move_from_immutable_to_mutable : Error<"cannot move immutable ${ 0 | select(value, variable '$1') } into a mutable binding">
def  err_cannot_move_immutable : Error<"cannot move immutable value '$0'">
def err_left_uninitialized : Error<"'$0' may not go out of scope while being partially uninitialized">
def err_type_not_found : Error<"type '$0' not found">
def err_not_copyable : Error<"type '$0' is not implicitly copyable${ 1 | if(, did you forget a '.copy()'?)}">

def err_module_not_found : Error<"module '$0' not found">
def err_submodule_not_found : Error<"module '$0' does not have a submodule named '$1'">

def err_uninitialized_local : Error<"'$0' may be uninitialized when used here">
def err_initialized_more_than_once : Error<"'$0' may be initialized more than once">
def note_previous_init_here : Note<"previous initialization was here">
def note_uninitialized_declared_here : Note<"was declared here">

def err_reassign_constant : Error<"cannot reassign 'let' constant">
def note_declared_const_here : Note<"'$0' declared as constant here">

def err_already_moved : Error<"'$0' cannot be moved since it may already have been ${ 1 | if(partially ) }moved before">
def err_move_after_borrow : Error<"cannot move '$0' while it is ${ 1 | if(partially ) }borrowed">
def err_borrow_after_move : Error<"cannot ${ 0 | if(mutably ) }borrow '$1' after it was ${ 2 | if(partially ) }moved">
def err_use_after_move : Error<"'$0' may be used after it was ${ 1 | if(partially ) }moved, did you mean to make a copy?">
def note_moved_here : Note<"move happened here">

def err_assign_type_mismatch : Error<"cannot assign value of type '$0' to type '$1'">
def err_cast_requires_op : Error<"cast between '$0' and '$1' requires '${ 2 | select(as, as?, as!) }' operator">

def err_access_member_on_type : Error<"cannot access member on value of type $0">
def err_access_member_on_pointer : Error<"cannot access member on pointer, did you mean to use '->'?">
def err_member_access_non_pointer : Error<"cannot apply member access operator '->' to non-pointer type $0">

def err_not_tuple : Error<"cannot access indexed member on type $0">
def err_tuple_arity : Error<"cannot access index $0 on tuple with arity $1">

def err_must_be_integral_constant : Error<"${ 0 | ordinal } argument to ${ 1 | select(function,primitive initializer) } must be an integral constant">
def err_must_be_floating_constant : Error<"${ 0 | ordinal } argument to ${ 1 | select(function,primitive initializer) } must be a floating point constant">

def err_circular_global_value : Error<"type inferred global values $0 and $1 are circularly dependent on each others value">
def note_dependent_global_here : Note<"dependent global here">

def err_value_is_not_enum : Error<"type $0 is not an enumeration">
def err_record_is_not_enum : Error<"${ 0 | select(class,struct,enum,union,protocol) } $1 is not an enumeration">

def err_subscript_too_many_indices : Error<"too many indices for subscript operator">
def err_vararg_cannot_pass_void : Error<"cannot pass 'void' to a vararg function">

def err_iterator_must_return_option : Error<"'next' function used in for-in must return an 'Option' type">
def err_could_not_infer_arr_element_type : Error<"could not infer array literal element type">

def err_no_builtin_decl : Error<"${ 0 | select(none, optional type, array literal, dictionary literal, string literal, 'Array' type, 'Dictionary' type, 'Option' type, failible cast, 'typeof', fallible init, 'try?', 'async / await', 'closure') } cannot be used because the declaration for '${ 0 | select(Option, Option, Array, Dictionary, String, Array, Dictionary, Option, Option, TypeInfo, Option, Option, Future, Box) }' was not found">

def err_builtin_decl_not_found : Error<"builtin declaration '$0' is missing">

def err_cannot_reference_type : Error<"type '$0' cannot be referenced">
def err_pointer_to_void : Error<"pointers to 'Void' are not allowed, use 'u8*' instead">

def err_array_size_too_large : Error<"fixed array size is too large (max. allowed size is $0, $1 given)">
def err_array_size_must_be_integral : Error<"fixed array size must be an integral constant">
def err_zero_size_array : Error<"fixed size arrays cannot have size zero">
def err_builtin_type_expects : Error<"'${ 0 | select(MetaType, UnsafePtr, UnsafeMutablePtr) }' type expects one type template argument">

def warn_expr_result_unused : Warning<"expression result unused">

def err_cannot_infer_array_size : Error<"cannot infer size of array type from given expression">

def err_referenced_while_evaluating : Error<"${ 0 | select(alias, function) } '$1' is referenced while being evaluated">

def err_multiple_modules : Error<"all source files in a compilation must be in the same module ('$0' and '$1' referenced in sources)">

// (Re-)Declaration
def err_redeclared_symbol : Error<"redeclaration of '$0'${ 1 | if( as a different kind of symbol) }">
def note_previous_decl : Note<"previous declaration here">

def err_redeclared_extern_c : Error<"redeclaration of extern C function '$0'">
def err_cannot_be_extern_C : Error<"function cannot be extern C">

def err_decl_requires_init : Error<"declaration of ${ 0 | select(local, global) } variable with inferred type requires an initializer">

def err_bad_destructure_type : Error<"type $0 cannot be destructured into type $1">
def err_bad_destructure_count : Error<"type $0 cannot be destructured into $1 values">
def err_ambiguous_destructure : Error<"reference to destructuring operator is ambiguous">

/* FUNCTION / METHOD CALL ERRORS */
def err_func_not_found : Error<"${ 0 | select(function, method) } '$1' not found">
def err_method_not_found : Error<"method '$0' does not exist on ${ 1 | if(instances of ) }type '$2'">
def err_no_matching_call : Error<"no matching call ${ 0 | if(for ${ 1 | select(function,method,alias) } '$2') } found">
def err_no_matching_initializer : Error<"no ${ 0 | select(matching , accessible ) }initializer for ${ 1 | select(class,struct,enum,union,protocol) } '$2' found">

def err_cannot_call : Error<"cannot call ${ 0 | select(typedef,namespace) }">
def err_cannot_call_method_on : Error<"cannot call method on value of type $0">
def err_cannot_call_type : Error<"cannot call type $0${ 1 | if(  statically) }">

def err_dot_init_must_be_on_self : Error<"'.init' must be called on 'self' or on a type name">
def err_dot_init_bad_type : Error<"cannot call '.init' on type '$0'">
def err_dot_init_outside_initializer : Error<"'self.init' cannot be called outside of an initializer">

def note_cand_no_implicit_conv : Note<"candidate not viable: no implicit conversion from '$0' to '$1' for ${ 2 | ordinal } argument${ 3 | if( (builtin operator candidate)) }">
def note_cand_no_implicit_conv_inferred : Note<"candidate not viable: no implicit conversion from '$0' to '$1' for ${ 2 | ordinal } argument (with template arguments inferred as [$3])">
def note_cand_failed_constraint : Note<"candidate not viable because of failed constraint: $0">
def note_cand_failed_constraint_inferred : Note<"candidate not viable because of failed constraint: $0 (with template arguments inferred as [$1])">
def note_cand_invalid_self : Note<"candidate not viable: 'self' argument has type '$0', '$1' given">
def note_cand_invalid_return : Note<"candidate not viable: return type is '$0', need '$1'">
def note_cand_label : Note<"candidate not viable: expected ${ 0 | select(no label, label '$0')} for ${ 1 | ordinal } argument, ${ 2 | select(none, label '$2')} given">
def note_too_few_arguments : Note<"candidate not viable: requires at least $0 ${ 0 | plural_s(argument) }, $1 given${ 2 | if( (builtin operator candidate)) }">
def note_too_many_arguments : Note<"candidate not viable: requires at most $0 ${ 0 | plural_s(argument) }, $1 given${ 2 | if( (builtin operator candidate)) }">
def note_too_few_arguments_inferred : Note<"candidate not viable: requires at least $0 ${ 0 | plural_s(argument) }, $1 given (with template arguments inferred as [$2])">
def note_too_many_arguments_inferred : Note<"candidate not viable: requires at most $0 ${ 0 | plural_s(argument) }, $1 given (with template arguments inferred as [$2])">
def note_candidate_requires_context : Note<"candidate not viable: could not infer type of ${ 0 | ordinal } argument">

def note_could_not_infer_template_arg : Note<"candidate not viable: could not infer template argument $0">
def note_inferred_template_arg_conflict : Note<"candidate not viable: conflicting ${ 0 | select(types,values) } $1 and $2 deduced for template argument $3">
def note_template_arg_kind_mismatch : Note<"candidate not viable: expected ${ 0 | select(typename, value, variadic typename, variadic value) } but found ${ 1 | select(typename, value, variadic typename, variadic value) } for ${ 2 | ordinal } argument">
def note_template_arg_type_mismatch : Note<"candidate not viable: expected $0 as ${ 1 | ordinal } argument but found $2">
def note_template_arg_covariance : Note<"expected type ${ 0 | select(conforming to protocol, that is a subclass of) } '$1' for template parameter '$2', but got '$3'">
def note_template_parameter_here : Note<"template parameter declared here">
def note_too_many_template_args : Note<"candidate not viable: expected at most $0 ${ 0 | plural_s(template argument) }, $1 given">

def note_method_must_be_static : Note<"candidate method not viable: not declared 'static'">
def note_candidate_is_mutating : Note<"candidate method not viable: 'mutating' method cannot be called on a ${ 0 | select(`let` constant, temporary) }">

def note_candidate_requires_ref : Note<"candidate function not viable: requires ${ 0 | if(mutable ) }${ 1 | select(reference, pointer) } for ${ 2 | ordinal } argument">

def err_ambiguous_call : Error<"call to ${ 0 | select(function, method, alias) } '$1' is ambiguous">
def note_candidate_here : Note<"candidate declared here">
def note_builtin_candidate : Note<"builtin ${ 0 | if(operator ) }candidate">

def err_ambiguous_reference : Error<"reference to '$0' is ambiguous">

def err_prop_does_not_have : Error<"property '$0' does not have a ${ 1 | select(getter, setter) }">
def err_subscript_does_not_have : Error<"susbcript does not have a ${ 0 | select(getter, setter) }">

def err_incompatible_template_args : Error<"incompatible template arguments for ${ 0 | select(class,struct,enum,union,protocol,alias) } $1">

def err_mutating_accessor_on_const : Error<"cannot access mutating ${ 0 | select(getter, setter) } on a 'let' constant">

// anonymous calls
def err_too_few_args_for_call : Error<"too few arguments for function call, expected $0 but found $1">
def err_too_many_args_for_call : Error<"too many arguments for function call, expected $0 but found $1">

// sizeof...
def err_variadic_sizeof_expects : Error<"expected variadic template parameter as argument to 'sizeof...'">
def err_does_not_name_template_parm : Error<"$0 does not name a ${ 1 | if(variadic ) }template parameter">

/* TEMPLATES */
def err_non_type_param_used_as_type : Error<"non-type template parameter $0 cannot be used as a type">

def note_instantiation_of : Note<"in instantiation of ${ 0 | select(class,struct,enum,union,protocol,function,method,alias,namespace) } '$1'${ 2 | if( with template arguments [$3]) }">

def err_protocol_template_params : Error<"protocols may not be templated, use associated types instead">
def err_invalid_pack_expansion : Error<"cannot apply pack expansion operator '...' to expression that does not contain a variadic template parameter or argument">
def err_pack_expansion_cannot_appear : Error<"pack expansion operator is not allowed here">
def err_unexpanded_pack : Error<"expression contains unexpanded parameter pack">
def err_variadic_field_type : Error<"type of variadic field must be a parameter pack expansion">

def err_template_param_shadow : Error<"template parameter '$0' shadows a template paramater in an enclosing scope">

def err_variadic_field_must_be_indexed : Error<"variadic field access must be indexed">
def err_variadic_field_single_index : Error<"variadic field expects a single index">
def err_variadic_field_index_integral : Error<"variadic field index must be a static integer">

def err_initializer_templ_args_must_be_inferrable : Error<"${ 0 | select(initializer) } template parameter '$1' must be used in the function signature">

def err_not_a_template : Error<"${ 0 | select(class,struct,enum,union,protocol,function,method,alias,namespace) } '$1' is not a template">

// CTFE errors
def err_ctfe_circular_dependence : Error<"functions '$0' and '$1' are circularly dependent on each others definition and cannot be statically evaluated">
def note_dependency_chain : Note<"chain of dependency: $0">
def note_called_here : Note<"called from here">
def err_maximum_recursion_depth : Error<"maximum recursion depth of $0 exceeded while evaluating function '$1'">
def err_maximum_branch_depth : Error<"maximum branching depth of $0 exceeded while evaluating function '$1'">
def err_no_definition : Error<"declared function '$0' cannot be evaluated at compile time">
def err_not_compiletime_evaluable : Error<"function '$0' cannot be evaluated at compile time, use @compiletime to make it evaluable">
def note_call_chain : Note<"call chain: $0">
def err_fn_called_during_ctfe : Error<"'$0' ${ 1 | select(was called, cannot be called) } during compile time function evaluation">
def err_unreachable_during_ctfe : Error<"'unreachable' instruction encountered during compile time function evaluation">

def note_printf_ctfe : Note<"'printf' encountered during ctfe: $0">

def err_size_not_known : Error<"size of ${ 0 | select(class,struct,enum,union,protocol) } '$1' is not known when requested here">

def err_cannot_persist_type : Error<"static expression cannot return value of type '$0' because it is not persistable">
def note_non_persistable_member_here : Error<"member of non-persistable type '$0' here">

// reflection error

def err_compiler_ns_unknown_entity : Error<"unknown entity '$0' in reserved 'Compiler' namespace">
def err_compiler_ns_bad_def : Error<"unexpected structure of '$0' entity in reserved 'Compiler' namespace">

def err_reflection_decl_not_found : Error<"declaration for '$0' was not found in 'Compiler' namespace">
def err_reflect_outside_func : Error<"'Compiler.${ 0 | select(function, mangledFunction) }' cannot be used outside of a function body">

def err_cannot_reflect_type : Error<"cannot reflect over type '$0'">

/* NAMESPACE ERRORS */
def err_namespace_not_found : Error<"namespace $0 does not exist">
def err_namespace_does_not_have_member : Error<"namespace $0 does not define member $1">
def err_import_multiple_with_wildcard : Error<"cannot import multiple items when a wildcard ('*') import is present">
def err_invalid_using_alias : Error<"cannot use named 'using' declaration when a wildcard import or multiple imported items are present">

def err_cannot_lookup_member_in : Error<"cannot lookup member in ${ 0 | select(class,struct,enum,union,protocol,function,method,alias,namespace,field,property,typedef,module) } '$1'">
def err_using_target_ambiguous : Error<"target of 'using' declaration is ambiguous">

/* CLASS / STRUCT ERRORS */
def err_class_not_accessible : Error<"${ 0 | select(class,struct,enum,union,protocol) } $1 is not accessible">
def err_class_not_found : Error<"class $0 not found">
def err_instantiate_abstract_class : Error<"cannot instantiate abstract class $0">
def err_member_not_found : Error<"${ 0 | select(class,struct,enum,union,protocol,function,method,alias,namespace, module) } '$1' does not have a member named '$2'">
def err_not_found : Error<"$0 not found">
def err_member_needs_initializing : Error<"member $0 must be initialized in every constructor">
def err_generic_type_not_found : Error<"${ 0 | select(class,struct,enum,union,protocol) } does not have a generic type $1">
def err_generic_type_count : Error<"expected $0 generic type ${ 0 | plural_s(argument) }, $1 given">
def err_generic_type_incompatible : Error<"generic type parameter $0 is not compatible with given type $1">
def err_struct_member_of_self : Error<"structs cannot have members of their own type (use a pointer instead)">
def err_constant_field_setter : Error<"constant fields cannot have a setter">
def err_self_outside_method : Error<"${ 0 | select(self, super, Self) } can only be used in instance methods">
def err_super_without_base : Error<"cannot reference 'super' because class $0 does not have a base class">

def err_no_template_method : Error<"${ 0 | select(class,struct,enum,union,protocol) } $1 does not have a templated method '$2'">

def err_overload_generic_params : Error<"${ 0 | select(function, method) } overloads must have the same template arguments">
def note_overload_generic_params : Note<"previous template argument list declared here">

def err_duplicate_method : Error<"duplicate declaration of ${ 0 | select(function, method) } $1">
def note_duplicate_method : Note<"previous declaration here">

def err_union_initializer_type : Error<"union initializer argument must be convertible to one of the unions types">

def err_enum_initializer : Error<"enums can only be constructed through one of their cases">
def err_protocol_initializer : Error<"protocols cannot be initialized">

def err_circular_data_members : Error<"circular dependency beetween fields of structs $0 and $1">
def note_other_field_here : Error<"dependent field here">

def err_non_static_member_accessed_statically : Error<"static ${ 0 | select(data member, property) } $1 of ${ 2 | select(class,struct,enum,union,protocol) } $3 cannot be accessed statically">

def err_implicit_conformance_cannot_be_declared : Error<"'${ 0 | select(Equatable,Hashable,StringRepresentable, Copyable) }' conformance cannot be implicitly declared: data member '$1' is not ${ 0 | select(equatable,hashable,string representable, copyable) }">

/* PROTOCOL ERRORS */
def err_protocol_not_found : Error<"protocol $0 does not exist">
def err_conforming_to_non_protocol : Error<"$0 is not a protocol">
def err_protocol_property_get_set : Error<"property in protocol must require a getter or setter">
def err_does_not_conform : Error<"${ 0 | select(class, struct, enum, union, protocol) } $1 does not conform to protocol $2">

def err_constraint_always_false : Error<"constraint is always false">
def err_cannot_be_used_as_concept : Error <"$0 '$1' cannot be used as a constraint">
def err_concept_must_be_bool : Error<"alias '$0' used as a constraint must return a boolean value">
def err_not_a_valid_concept : Error<"alias '$0' cannot be used as a constraint because ${ 1 | select(its value is not boolean, it does not have exactly one type template parameter) }">

def err_unconstrained_lookup : Error<"cannot lookup member in unconstrained associated type '$0'">
def err_cannot_be_referenced_in_constraint : Error<"$0 '$1' cannot be referenced in a constraint">

def err_protocol_cannot_be_used_as_type : Error<"protocol '$0' with associated type constraints can only be used as a generic constraint">

def err_incorrect_protocol_impl : Error<"${ 0 | select(class, struct, enum, union, protocol) } $1 does not correctly implement protocol $2">
def note_incorrect_protocol_impl_prop : Note<"required ${ 0 | select(subscript, property) } ${ 0 | if('$1' ) }${ 2 | select(is missing, requires a getter, requires a setter, requires a getter and a setter) }">

def note_incorrect_protocol_impl_method_missing : Note<"required method '$0' is missing">
def note_incorrect_protocol_impl_method_num_args : Note<"candidate has incorrect number of arguments, expected ${ 0 | select(at least, at most) } $1, $2 given">
def note_incorrect_protocol_impl_method_signature : Note<"candidate has incomaptible signature ('$0' expected for ${ 1 | ordinal } argument, found '$2')">
def note_incorrect_protocol_impl_method_return_type : Note<"candidate has incomaptible return type ('$0' expected, found '$1')">
def note_incorrect_protocol_impl_method_label : Note<"expected label '$0' for ${ 1 | ordinal } argument, ${ 2 | select(none, '$3') } given">
def note_incorrect_protocol_impl_method_no_label : Note<"expected no label for ${ 0 | ordinal } argument, '$1' given">
def note_incorrect_protocol_impl_attr : Note<"${ 0 | select(throwing, unsafe, async, mutating, non-static, static) } function cannot satisfy ${ 0 | select(non-throwing, non-unsafe, non-async, non-mutating, static, non-static) } protocol requirement">
def note_incorrect_protocol_impl_fallible : Note<"candidate is fallible, non-fallible init required">

def err_circular_conformance : Error<"circular protocol conformance between '$0' and '$1'">
def note_conformance_chain : Note<"conformance chain: $0">

def note_incorrect_protocol_impl_prop_type : Note<"${ 0 | select(subscript, property) } ${ 0 | if('$1' ) }has incompatible type, expected $2 but found $3">

def err_definition_in_protocol : Error<"${ 0 | select(method, property, subscript, initializer) } in a protocol may not have a body, use an extension instead">
def err_may_not_appear_in_protocol : Error<"${ 0 | select(class,struct,enum,union,protocol,function,method,alias,namespace,field,property,typedef,module) } declaration cannot appear in a protocol">
def err_protocol_extension_must_override : Error<"declaration in protocol extension must override a protocol requirement">

def note_associated_type_missing : Note<"associated type '$0' must be defined">
def err_no_such_associated_type : Error<"${ 0 | select(class, struct, enum, union, protocol) } '$1' does not conform to a protocol with an associated type named '$2'">
def err_associated_type_ambiguous : Error<"reference to associated type '$0' is ambiguous">
def err_associated_type_no_default : Error<"must specify a type for associated type '$0' because it does not have a default type">
def err_associated_type_constraint : Error<"associated type '$0' (aka $1) does not satisfy constraint: $2">

def err_constraint_not_satisfied : Error<"unsatisified constraint${ 0 | if(: ) }$1">
def note_constraint_here : Note<"constraint declared here">

def err_mutating_on_class : Error<"'mutating' cannot be used on class methods">

def err_cannot_assign_to_self : Error<"cannot assign to 'self' in non mutating method">
def err_cannot_assign_to_property : Error<"cannot assign to property in non mutating method">
def note_mark_mutating : Note<"mark method as 'mutating' to make 'self' mutable">

def err_self_used_before_initialized : Error<"'self' cannot be accessed before all properties are initialized">
def note_uninitialized_property : Note<"property '$0' is not yet initialized">
def err_field_must_be_initialized : Error<"property '$0' must be initialized before the end of the constructor">

/* ENUM ERRORS */
def err_enum_case_not_found : Error<"enum $0 does not define case $1 ${ 2 | if(with the given arguments) }">
def err_enum_case_wrong_no_args : Error<"case $0 requires $1 arguments, $2 given">

/* TUPLE ERRORS */
def err_indexed_prop_on_nun_tuple : Error<"cannot access indexed property on non-tuple type $0">
def err_index_higher_than_arity : Error<"cannot access index $0 on tuple with arity $1">

/* ATTRIBUTE ERRORS */
def err_attr_not_applicable : Error<"attribute '$0' is not valid here">
def err_attr_does_not_exist : Error<"unknown attribute '$0'">

def err_alias_without_value : Error<"alias declaration must have a value">

/* INITIALIZATION ERRORS */
def err_not_initialized : Error<"value with no default constructor must be explicitly initialized">
def err_var_redeclaration : Error<"redeclaration of variable $0">
def note_var_redeclaration : Note<"previous declaration is here">
def err_undeclared_identifer : Error<"reference to undeclared identifier $0">

/* ACCESS ERRORS */
def err_private_access : Error<"private ${ 0 | select(class,struct,enum,union,protocol,function,method,alias,namespace,field,property,typedef,module) } '$1' is not accessible here">
def err_fileprivate_access : Error<"fileprivate ${ 0 | select(class,struct,enum,union,protocol,function,method,alias,namespace,field,property,typedef,module) } '$1' can only be accessed within file '$2'">
def err_protected_access : Error<"protected ${ 0 | select(class,struct,enum,union,protocol,function,method,alias,namespace,field,property,typedef,module) } '$1' can only be accessed within class '$2' or subclasses of it">
def err_internal_access : Error<"internal ${ 0 | select(class,struct,enum,union,protocol,function,method,alias,namespace,field,property,typedef,module) } '$1' can only be accessed within module '$2'">

def note_access_spec_here : Note<"${ 0 | if(implicitly ) }declared ${ 1 | select(<<<should not happen>>>, public, private, protected, internal, fileprivate) } here">

def err_protected_outside_class : Error<"'protected' access specifier can only be used in a class declaration">

def err_bad_main_def : Error<"'main' may not ${ 0 | select(throw, be unsafe, be async, return a type other than 'Int' or 'Void') }">
def err_bad_main_sig : Error<"invalid main signature (valid ones are () and (Int, UnsafePtr[UnsafePtr[u8]]))">

def note_imported_from_module : Note<"imported from module '$0' here">
def err_circular_module_dependency : Error<"circular dependency between modules '$0' and '$1'">

def err_llvm_function_name_reserved : Error<"function names starting with 'llvm.' are reserved">

/* KEYWORD ERRORS */
def err_return_outside_func : Error<"keyword 'return' is only allowed in function bodies">
def err_return_ref : Error<"cannot return value of reference type '$0'${ 1 | if(, did you mean to make a copy?) }">

def err_loop_keyword_outside_loop : Error<"keyword '${ 0 | select(continue, break) }' is only valid in loop bodies">
def err_loop_label : Error<"no loop with label '$0' is in scope">

def err_no_type_after_as : Error<"expected type after 'as'">
def err_duplicate_label : Error<"duplicate label '$0'">
def note_duplicate_label : Note<"previous label here">
def err_label_not_found : Error<"no label $0 to go to">
def err_goto_skips_decl : Error<"goto statement cannot jump over variable declaration">
def note_goto_skipped_decl : Note<"skipped declaration of variable $0 here">

def err_static_assert_failed : Error<"static assertion failed${ 0 | if(: ) }$1">
def err_cant_print_expr : Error<"cannot static_print expression of type $0">
def note_static_print : Note<"$0">

/* __traits */
def err_traits_expects_tuple : Error<"__traits(${ 0 | select(arity) }) expects a tuple as its only argument">
def err_traits_expects_int : Error<"__traits(${ 0 | select(bitwidth_of) }) expects an integral type or value">
def err_traits_expects_fp : Error<"__traits(${ 0 | select(fp_precision) }) expects a floating point type or value">

/* OPERATORS */
def err_incompatible_binop_types : Error<"${ 0 | select(left, right) } hand side of binary operator '$1' must be ${ 2 | select(integral, floating point, boolean) }">
def err_binop_not_applicable : Error<"cannot apply binary operator '$0' to values of type $1 and $2">
def err_different_operand_types : Error<"both operands to binary operator '$0' must be of the same type, $1 and $2 given">

def err_unary_op_not_applicable : Error<"cannot apply ${ 0 | select(prefix, postfix) } unary operator '$1' to ${ 2 | select(value, rvalue) } of type $3">
def err_const_unary_op : Error<"mutating unary operator '$0' cannot be applied to a constant value">
def err_dereference_non_pointer : Error<"cannot dereference non-pointer type $0">
def err_reference_non_lvalue : Error<"cannot take address of rvalue of type $0">

def err_unexpected_expression : Error<"unexpected expression; expecting binary operator">

/* MATCH STMT */
def err_match_value_not_equatable : Error<"matched value must be enum or conform to equatable">
def err_invalid_match : Error<"cannot match values of types $0 and $1">

def err_duplicate_case : Error<"duplicate case '$0' in match statement">
def note_duplicate_case : Note<"previous case ${ 0 | select(is here, binds all associated values) }">

def err_continue_from_last_case : Error<"cannot continue from last case in a match statement">
def err_continue_case_with_bound_vals : Error<"cannot continue to case with bound values">

def err_match_not_exhaustive : Error<"match statements must be exhaustive">
def note_missing_case : Note<"case '$0' is either missing or contains expression checks">

/* FUNCTION RETURNS */
def warn_main_return_type : Warning<"return type of 'main' will always be set to i64">
def err_main_invalid_signature : Error<"invalid signature for 'main'">
def err_returning_incomp_type : Error<"returning value of type $0 from function with declared return type $1">
def err_not_all_code_paths_return : Error<"not all code paths return a value">
def err_unreachable_code : Error<"unreachable code">
def err_fallible_init_return : Error<"fallible initializers may only return a 'none' literal">
def err_fallible_init_in_non_fallible_init : Error<"fallible initializers can only be called from within another fallible initializer">
def err_return_in_noreturn_func : Error<"function that returns an unpopulated type may not return normally">
def err_control_reaches_end_noreturn : Error<"control reaches the end of a noreturn function">
def err_func_redeclaration : Error<"redeclaration of ${ 0 | select(function,method) } $1 with the same signature as a previous declaration">
def note_func_redeclaration_memberwise_init : Note<"previous declaration is the memberwise initializer">
def note_func_redeclaration : Note<"previous declaration is here">

/* LAMBDA EXPRESSIONS */
def err_incomp_arg_counts : Error<"incompatible argument count: expected $0 but got $1">
def err_lambda_arg_default_val : Error<"lambda expression arguments cannot have default values">

def err_lambda_could_not_infer_type_name : Error<"could not infer type of argument '$0'">
def err_lambda_could_not_infer_type : Error<"could not infer type of ${ 0 | ordinal } argument of lambda expression">

/* TYPEDEF */
def err_typedef_generic_not_provided : Error<"generic type $0 not provided for typedef">

/* EXCEPTIONS */
def err_throw_in_non_throwing_fn : Error<"'throw' cannot appear in a non-throwing function '$0'">
def err_throwing_fn_called_in_non_throwing : Error<"cannot call throwing function '$0' in non-throwing function '$1'">

def err_try_without_call_to_throwing_fn : Error<"expression after 'try' must contain a call to a throwing function">

def err_throwing_call_not_in_try : Error<"call to throwing function '$0' must appear in a 'try' expression">
def err_try_in_non_throwing_fn : Error<"'try' may only appear in a throwing function or an exhaustive 'do' statement">

def err_not_throwable : Error<"${ 0 | select(thrown,caught) } value must conform to 'Throwable'">
def err_duplicate_catch : Error<"equivalent catch statements">
def note_previous_catch : Note<"previous catch statement was here">
def err_catch_all_must_be_alone : Error<"catch-all statement must appear alone">

// Async / Await

def err_await_in_non_async_fn : Error<"'await' can only appear in the body of an 'async' function">

// borrow checking
def err_cannot_borrow : Error<"cannot ${ 0 | if(mutably ) }borrow '$1' since there is already a ${ 2 | if(mutable ) }borrow active">
def note_borrow_begins_here : Note<"previous borrow begins here">
def note_borrow_ends_here : Note<"previous borrow ends here">

def err_cannot_move : Error<"${ 0 | select(global variable)} cannot be moved">
def err_cannot_move_field : Error<"cannot move field of ${ 0 | select(global variable, class) }">

// mixins
def err_invalid_mixin_kind : Error<"mixin in ${ 0 | select(expression,declaration,statement) } position must form a valid ${ 0 | select(expression,declaration,statement) }">
def err_mixin_expr_must_be_string : Error<"mixin expression must be of type 'String' ('$0' given)">

// backend
def err_llvm_backend : Error<"an error occured in the LLVM backend: '$0'">
